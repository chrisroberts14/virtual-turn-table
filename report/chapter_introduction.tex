\chapter{Introduction}\label{cha:intro}

\section{Project Overview And Motivations}
Since the advent of music streaming services user numbers have grown steadily, resulting in an industry with approximately \$$19.3$ billion in revenue in 2023~\cite{IFPI}. Despite this, vinyl records have seen a resurgence in their sales~\cite{BPI}, but the need for additional hardware is a barrier for most listeners.
This project attempts to remedy this issue by providing an alternative to traditional turntables with a virtual version. It will not suffer from the lack of portability and high costs associated with physical turntables. By taking advantage of web technologies it can allow users to play their collections from the convenience of their digital devices at no additional cost whilst attempting to emulate the feel of dropping the needle on an LP.

\section{Objectives}\label{sec:objectives}
The project, at its simplest, must match the capability of a physical turntable whilst being entirely on a digital device. That is it must meet the following criteria:
\begin{itemize}
    \item Play whole albums using a representation of the physical album as input
    \item Accurately determine which album is input
\end{itemize}
On top of these basic requirements, as the project is to be used on digital devices, it should meet criteria which are common to products produced in this domain:
\begin{itemize}
    \item Visually appealing user interface
    \item Easy to use user interface
    \item Social system between users
    \item Save users collections for easier repeat listens
\end{itemize}
As an extension to these goals, there are certain criteria that are considered good software development practices, these goals should also be met during development:
\begin{itemize}
    \item High code quality
    \item Automated testing
    \item Automated deployment
    \item Automated dependency management
\end{itemize}

\section{Project Plan}
In order to ensure design criteria are met and tasks are completed on time, an effective plan was required, even though work on this project was being completed by a solo developer. For this project, an agile approach was adopted which provides greater flexibility and supported an iterative development approach~\cite{agile_software_development} which met the desire for a fast development process. This is in contrast to traditional methodologies such as Waterfall~\cite{5222784}, which is better suited for projects with a well-defined scope and stable requirements something which was not suitable for this project.

\subsection{Planning system}~\label{sec:plan-system}
Kanban systems are a popular choice for managing software development projects, providing a visual representation of tasks and their progress~\cite{5773404}. Tasks were categorised into three stages: Backlog, In Progress, and Done, as shown in Figure~\ref{fig:kanban-board}. This system provided a clear overview of remaining work while also enabling tasks to be prioritised, ensuring that more important work, such as that composing the critical functionality, was completed first.

Critically, the planning system needed to be easy to set up and use, to avoid consuming unnecessary time. For this purpose, a GitHub Project was selected, as it required minimal setup and configuration. Additionally, it integrated directly with the project repository, enabling direct links between commits, pull requests and tasks.

\begin{figure}
    \centering
    \includegraphics[width=0.65\linewidth]{figures/kanban_board.png}
    \captionsetup{justification=centering,margin=2cm}
    \caption{The Kanban board used during the project with tickets across the three columns}
    \label{fig:kanban-board}
\end{figure}

\subsection{Plan}~\label{sec:plan}
The plan for this project was structured into four key phases: design, development and testing, deployment and maintenance, and the evaluation.

\subsubsection{Design}
The first stage of the project involved finalising the system design before commencing code development. This high-level planning approach addressed key architectural and technological decisions early in the process, ensuring a well-defined foundation. By making these decisions in advance, the need for ad hoc choices during development was minimised, reducing the risk of unintended consequences later in the project. This phase established the system's architecture, technology stack, deployment strategy, and user interface design, all of which are further detailed in Chapter~\ref{cha:design}.

\subsubsection{Development And Testing}
The development phase encompassed both the implementation of the core software and the integration of automated code quality tools to maintain consistency and reliability. A test-driven development (TDD) approach was adopted, which would ensure tests covered all intended functionality and decrease the chances of errors making it into the application~\cite{10.1145/952532.952753}. This included the creation of automated tests, reducing reliance on manual testing, which was particularly useful as the project grew in size. Additionally, linters, formatters, and continuous testing were incorporated to enforce code quality standards as each commit was pushed to the repository, as further discussed in Section~\ref{sec:code-quality}.

The Kanban project planning system, outlined in Section~\ref{sec:plan-system}, would play a crucial role in managing unforeseen challenges during development, such as bugs, which could be easily added to the board without disrupting the overall plan.

\subsubsection{Deployment And Maintenance}
Deployment was planned to involve hosting the system on a cloud platform to allow access from any potential user. The specific deployment method would be determined by the system’s design (Chapter~\ref{cha:design}), but a cloud-based solution was preferred due to its minimal cost for small projects and ease of configuration.

Maintenance was not a primary focus during planning; however, certain aspects were considered. Automated dependency management was planned, with bots monitoring the repository’s dependency files and updating them as new versions were released. Combined with the automated test suite, this approach ensured that dependencies could be updated with confidence and minimal manual intervention.

\subsubsection{Evaluation}
The intention was to evaluate the project at the end of the development phase to ensure that the project met the objectives set out in Section~\ref{sec:objectives}. This evaluation would involve testing the accuracy of the album identification method and surveying a sample of users to understand the reaction to the user interface. The results of this would be used to inform what future work would be needed to improve the application.
